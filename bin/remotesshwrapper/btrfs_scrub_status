#!/usr/bin/env perl
use JSON;
use Date::Parse;
use POSIX qw( floor );

my %scrub_status;
my $mountpts_ref = decode_json($ARGV[0]);
my @mountpts = @{ $mountpts_ref };

foreach my $mount ( @mountpts ) {
    my $output     = `/sbin/btrfs scrub status $mount`;
    my $statustext = "unknown";
    my $status     = "0";
    my $stats      = "unknown";
    my $css_class  = "";

    my ($statustext, $stats) = $output =~ m/\n\t(.*)\n\t(.*)$/;
    chomp $statustext;
    chomp $stats;
    my ($starttime, $runtime) = $statustext =~ m/at (\w{3} \w{3}\s+\d+ \d+:\d+:\d+ \d{4}).* (\d+)/;
    $starttime  = str2time($starttime);
    my $minutes = $runtime / 60;

    if ( $minutes < 60 ) {
        if ($minutes < 1 ) {
            $runtime = sprintf( "< 1 min", $minutes );
        } else {
            $runtime = sprintf( "%d min", $minutes );
        }
    } else {
        $runtime = sprintf( "\%dh\%02dmin", floor( $minutes / 60 ), $minutes % 60 );
    }

    if ( $statustext =~ m/no stats available/) {
        $statustext = "-";
        $stats      = "";
        $runtime    = "";
    } elsif ($output =~ m/running/s) {
        $css_class = "running";
        $status    = "3";
    } elsif ($output =~ m/finished/s) {
        $css_class = "finished";
        $status    = "1";
    } elsif ($output =~ m/aborted/s) {
        $css_class = "aborted";
        $status    = "2";
    }

    $scrub_status{$mount} = {
        'statustext' => $statustext,
        'status'     => $status,
        'starttime'  => $starttime,
        'runtime'    => $runtime,
        'stats'      => $stats,
        'css_class'  => $css_class,
    };
}

my $json = JSON->new->allow_nonref;
my $json_text = $json->encode(\%scrub_status);
print "$json_text";
