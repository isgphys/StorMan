#!/usr/bin/env perl
use JSON;
use Date::Parse;
use POSIX qw( floor );

my $BTRFS = "/usr/bin/btrfs";

my %scrub_status;
my $mountpts_ref = decode_json($ARGV[0]);
my @mountpts = @{ $mountpts_ref };

foreach my $mount ( @mountpts ) {
    next unless $mount =~ m/^[a-zA-Z0-9_\-\/]+$/;
    my @output     = `$BTRFS scrub status $mount`;
    my $statustext = "unknown";
    my $status     = "0";
    my $stats      = "unknown";
    my $css_class  = "";
    my $starttime;

    foreach my $line ( @output ) {
        if ( $line =~ m/no stats available/ ) {
            $statustext = "-";
            $stats      = "";
            $runtime    = "";
        } elsif ( $line =~ qr{ at \s (?<starttime>\w{3} \s \w{3}\s+\d+ \s \d+:\d+:\d+ \s \d{4}) }x ) {
            $statustext = $line;
            $starttime  = $+{starttime};

            $starttime  = str2time($starttime);

            if ($statustext =~ m/running/) {
                $css_class = "running";
                $status    = "3";
            } elsif ($statustext =~ m/finished/) {
                $css_class = "finished";
                $status    = "1";
            } elsif ($statustext =~ m/aborted/) {
                $css_class = "aborted";
                $status    = "2";
            }
        } elsif ( $line =~ m/total/ ) {
            $stats = $line;
        } elsif ( $line =~ m/error details/ ) {
            $stats    .= "<br>$line";
            $css_class = "error";
        } elsif ( $line =~ m/corrected errors/ ) {
            $stats .= "<br>$line";
        }
    }

    $scrub_status{$mount} = {
        'statustext' => $statustext,
        'status'     => $status,
        'starttime'  => $starttime,
        'stats'      => $stats,
        'css_class'  => $css_class,
    };
}

my $json = JSON->new->allow_nonref;
my $json_text = $json->encode(\%scrub_status);
print "$json_text";
